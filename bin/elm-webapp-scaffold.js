#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const binName = path.basename(process.argv[1])
const targetName = process.argv[2]
const dstDirectory = process.argv[3] || '.'
if (!targetName) {
  console.error(`

USAGE:

  ${binName} <TypeName> [target_directory]

TYPENAME:

  Adds a new CRUD application to your existing application
  generated from "elm-webapp crud"

EXAMPLE:

  ${binName} Article blog

  will generate a CRUD application for "Article" in "./blog"

SEE ALSO:

  elm-webapp

ADVANCED:

  SCAFFOLD_DIFF_FILE  to use a different 'diff' file
  SCAFFOLD_PATCH_P    custom number of leading components to
                      strip from 'diff' file names

    `)
  process.exit(1)
}
const data = fs.readFileSync(process.env.SCAFFOLD_DIFF_FILE || path.join(__dirname, '../templates/crud.diff'), 'utf-8')
const pflag = parseInt(process.env.SCAFFOLD_PATCH_P || 2, 10) // `-p` flag of `patch`
const targetTypeName = targetName.substring(0, 1).toUpperCase() + targetName.substring(1)
const targetVarName = targetName.substring(0, 1).toLowerCase() + targetName.substring(1)

// "+++ some/path/file/name.ext\tyyyy-mm-dd"
function filepathFrom (line) {
  const parts = line.split('\t')[0].substring(4).split(path.sep)
  for (let i = pflag; i > 0; i--) parts.shift()
  return parts.join(path.sep)
}

// @@ ..... @@ fname arg =
function functionLineFrom (line) {
  if (line.endsWith(' @@')) return
  return line.substring(line.lastIndexOf(' @@ ') + 4)
}

//
// state= {
//   filepath: 'src/Server.elm',
//   functionLine: 'updateFromClient : Protocol.RequestConte',
//   before: [
//     'updateFromClient ctx now clientMsg serverState =',
//     '    case clientMsg of'
//   ],
//   body: [
//     '        Protocol.MsgFromFoobar m ->',
//     '            Server.FoobarAPI.updateFromClient ctx now m serverState',
//     ''
//   ],
//   after: [
//     '        Protocol.ManyMsgFromClient msglist ->',
//     '            -- Handling a batched list of `MsgFromClient`',
//     '',
//     ''
//   ]
// }
//
function apply (state) {
  const fullpath = path.join(dstDirectory, state.filepath)
  const fileExist = !!fs.statSync(fullpath, { throwIfNoEntry: false })

  if (!state.functionLine) {
    console.log('creating', state.filepath, '...')
    if (fileExist) {
      console.error(`File already exist: ${state.filepath}

Choose a different TypeName?
`)
      process.exit(1)
    }
    fs.mkdirSync(path.dirname(fullpath), { recursive: true })
    fs.writeFileSync(path.join(dstDirectory, state.filepath), state.body.join('\n'))
  } else {
    console.log('patching', state.filepath, '...')
    const originalLines = fs.readFileSync(path.join(dstDirectory, state.filepath), { encoding: 'utf8' }).split('\n')
    const patchedLines = tryPatching(state, originalLines)
    return fs.writeFileSync(path.join(dstDirectory, state.filepath), patchedLines.join('\n'))
  }
}

function errorExit(str) {
  console.error(str)
  process.exit(1)
}

function check(state) {
  const fullpath = path.join(dstDirectory, state.filepath)
  const fileExist = !!fs.statSync(fullpath, { throwIfNoEntry: false })
  if (!state.functionLine && fileExist) {
    errorExit(`File already exist: ${state.filepath}\n\nChoose a different TypeName?\n`)
  } else if (state.functionLine && !fileExist) {
    errorExit(`File does not exist: ${state.filepath}\n\nWe can only add scaffold into directory '${dstDirectory}' if it was generated by 'elm-webapp crud ${dstDirectory}'\n`)
  }
}

function prefix (prefixString) {
  return function (line) {
    return prefixString + line
  }
}

function errorStateExit (state) {
  console.error(
    ['',
      prefix(' ')(state.functionLine),
      ...state.before.map(prefix(' ')),
      ...state.body.map(prefix('+')),
      ...state.after.map(prefix(' ')),
      ''
    ].join('\n'))
  errorExit('Patch failed!')
}

function tryPatching (state, srcLines) {
  let fromIndex = srcLines.findIndex(function (line, index) { return line.startsWith(state.functionLine) })
  if (fromIndex === -1) errorStateExit(state)

  const beforeIndexes = state.before.map(function (line) {
    fromIndex = srcLines.indexOf(line, fromIndex)
    return fromIndex
  })
  if (beforeIndexes.indexOf(-1) === -1) {
    srcLines.splice(Math.max(...beforeIndexes) + 1, 0, ...state.body)
    return srcLines
  }

  const afterIndexes = state.after.map(function (line) {
    fromIndex = srcLines.indexOf(line, fromIndex)
    return fromIndex
  })
  if (afterIndexes.indexOf(-1) === -1) {
    srcLines.splice(Math.min(...beforeIndexes) - 1, 0, ...state.body)
    return srcLines
  }

  // cannot locate insertion point by either before nor after
  errorStateExit(state)
}

function escapeRegExp (string) {
  return string.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&') // $& means the whole matched string
}

function rename (line) {
  return line
    .replace(new RegExp(escapeRegExp('Foobar'), 'g'), targetTypeName)
    .replace(new RegExp(escapeRegExp('foobar'), 'g'), targetVarName)
}

let patches = []
let state = {}

data.split('\n').forEach(function (line) {
  if (line.startsWith('diff ')) {
    if (state.body) patches.push(state)
  } if (line.startsWith('--- ')) {
    // ignore
  } if (line.startsWith('+++ ')) {
    state = {
      filepath: rename(filepathFrom(line))
    }
  } else if (line.startsWith('@@ ')) {
    if (state.body) patches.push(state)
    state = {
      filepath: rename(state.filepath),
      functionLine: functionLineFrom(line),
      before: [],
      body: [],
      after: []
    }
  } else if (line.startsWith('+')) {
    state.body.push(rename(line.substring(1)))
  } else if (state.body && state.body.length === 0) {
    state.before.push(line.substring(1))
  } else if (state.body) {
    state.after.push(line.substring(1))
  }
})
if (state.body) patches.push(state)

patches.forEach(check)
patches.forEach(apply)